[[mavenn-introducion]]

////
a=&#225; e=&#233; i=&#237; o=&#243; u=&#250;

A=&#193; E=&#201; I=&#205; O=&#211; U=&#218;

n=&#241; N=&#209;
////

== INTRODUCI&#211;N

* Maven es una herramienta de gesti&#243;n de proyectos. yyy

* Se basa en un fichero central, pom.xml, donde se define todo lo que necesita el proyecto.

* Maven maneja las dependencias del proyecto, compila, empaqueta y ejecuta los test.

* Mediante plugins, permite hacer mucho mas, como por ejemplo desplegar la aplicaci&#243;n, etc.

* Lo mas &#250;til de Maven, es el manejo de las dependencias, solo se necesita definir en el pom.xml las dependencias
  que se necesitan y maven las descarga y las a&#241;ade al classpath.

== A Maven project

A Maven project is simply a folder in your filesystem (also known as the project root folder) that contains a file called pom.xml, the XML representation
of your Project Object Model (POM); this is the first and most important Maven convention.

This minimal structure allows you to run a mvn command from the project root folder. By default, the mvn command searches for a pom.xml file in the local folder and it stops immediately if it is not able to find it.

By convention, all artifacts generated by the build are delivered in a folder relative to the pom.xml location known as Build Directory (the target by default). Since the target is generated on each build, it is:

* Safe to delete it anytime

* Crucial to ignore it when sharing the project using a Version Control System software

A Maven project defines a packaging, which identifies the main objective of the build, which in turn specifies the artifact that is going to be produced by the
invocation of the build.Default JAR (other values are EAR, EJB, RAR, PAR, WAR, and POM).

POM packaging is an exception, since:

* The Maven build does not produce an artifact

* The Maven build considers as the only artifact the main pom.xml file of the Maven project

A POM Maven project can be useful for the following activities:

* Aggregate dependencies (for more information, you can navigate to Lifecycle | Dependency Management)

* Parent POM (for more information, you can navigate to Lifecycle | Multi-module project)

http://maven.apache.org/ref/3.1.1/maven-model-builder/super-pom.html


== Creating from an archetype

Now it's time for some action! We are creating a new Java project—containing a Maven build—starting from an archetype, using the maven-archetype-quickstart command (we will read more about archetypes in the next section). You don't need to create any file or folder in advance; Maven will take care of creating the root project folder and the initial content.

* Run the following command:

 mvn archetype:generate -DgroupId=com.mycompany.demo -DartifactId=myapp -DarchetypeArtifactId=maven-archetype-quickstart-DinteractiveMode=false

As you can see, the command specifies one property for each coordinate that identifies the archetype http://search.maven.org/#artifactdetails_org.apache.maven.archetypes_maven-archetype-quickstart_1.1_maven-archetype.

The preceding command will ask you some information regarding the project (groupId, artifactId, version) you're about to create. The rules for Maven artifact coordinates apply; so let's assume the following values:

[source, JAVA]
----
groupId: com.mycompany.demo
artifactId: myapp
version: 1.0-SNAPSHOT
----

If everything goes fine, the end of the output should be similar to the following:

[source, JAVA]
----
[INFO] BUILD SUCCESS
[INFO] ----------------------------------------------------------
[INFO] Total time: 12.653s
[INFO] Finished at: Sun Mar 17 16:38:36 CET 2013
[INFO] Final Memory: 7M/265M
[INFO] ----------------------------------------------------------
[source, JAVA]
----

The process will download the needed dependencies into your Maven Local Repository; with a fast connection, you should be done in less than a minute.

The root project folder—with the same name as the artifactId coordinate you've specified earlier—should now
be located in the same place where you ran the last mvn command.


== Exploring the project structure

Let's now explore the newly created myapp folder. At the first level, you can see POM represented by the pom.xml file; the src folder contains all other project files.

The project file's structure will be as follows:

[source, JAVA]
----
myapp
|-- pom.xml
|-- src
|   '-- main
|     '-- java
|       '-- com
|         '-- mycompany
|           '-- demo
|             '-- App.java
|   '-- test
|     '-- java
|       '-- com
|         '-- mycompany
|           '-- demo
|             '-- AppTest.java
----

The components of the structure are explained as follows:

* *pom.xml:* Defines the project's coordinates, a profile, and some dependencies.

* *src/main/java:* Contains the project's source code. You can see that a sample App.java file has been created, which contains a Java "Hello World" application.

* *src/test/java:* Contains a JUnit test.


=== Exploring POM

The following code snippet shows the reported pom.xml content:

[source, XML]
[subs="verbatim,attributes"]
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.mycompany.demo</groupId>
    <artifactId>myapp</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>myapp</name>
    <url>http://maven.apache.org</url>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
----

The pom.xml file that is defined is simple and easy to understand:

* It defines a *<packaging>jar</packaging>* element, therefore we expect to produce a JAR file from this build

* It specifies a dependency to the JUnit library, limiting it to test the scope (scopes are explained in the next section)

* It defines all the coordinates to identify it as an artifact (*groupId*, *artifactId*, and *version*),
  which are the same that are typed when running mvn archetype:generate:

** *groupId:* Represents the group, company, team, organization, and/or project

** *artifactId:* Represents the name of the project (or project module)

** *version:* Represents the number of the current release; since our version ends with SNAPSHOT,
   it means that this is an unreleased project (development is in progress)

=== Compile, install, and run

From the root project folder, run *mvn install* and check the target folder. Maven generates the following files and folders in the target folder:

* *classes:* Contains the compiled Java sources (.class files) found in src/main/java and also the contents of src/main/resources (in our case it is empty). Used by the resources:resources andcompiler:compile goals.

* *test-classes:* This is the same as classes, but it is applied to src/test/java and src/test/resources. Used by the resources:testResources and compiler:testCompile goals.

* *maven-archiver:* Contains a manifest file of the Maven project; you can read more on the Maven official documentation available at http://maven.apache.org/shared/maven-archiver/index.html.

* *surefire-reports:* Contains the Surefire Plugin reports; the folder is empty, since no tests are defined in this project (src/main/test is empty). Created by the surefire:test goal.

* *myapp-1.0-SNAPSHOT.jar:* Contains the contents of the classes folder compressed in a JAR. Created by the jar:jar goal.

The same JAR file has been copied into your Maven Local Repository by the install:install goal, and it is located
in *~/repository/com/mycompany/demo/myapp/1.0-SNAPSHOT/myapp-1.0-SNAPSHOT.war.*

* To run a console Java application packaged as a JAR file, the command is as follows:

  java -jar target/myapp-1.0-SNAPSHOT.jar

Unfortunately, we forgot to insert into the JAR archive any information about what the main executable class is, so we get an error message as follows:

[source, console]
----
Failed to load Main-Class manifest attribute from
myapp-1.0-SNAPSHOT.jar
----

To solve this issue, you can use maven-jar-plugin (more information is available at
http://maven.apache.org/shared/maven-archiver/examples/classpath.html as follows:

[source, XML]
[subs="verbatim,attributes"]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <archive>
            <manifest>
                <mainClass>com.mycompany.demo.App</mainClass>
            </manifest>
        </archive>
    </configuration>
</plugin>
----

Now you can run mvn clean install to (re)create the JAR file containing a complete Java manifest file, with the following line:

  Main-Class: com.mycompany.demo.App

You can now confidently run the application, using the following command:

  java -jar target/myapp-1.0-SNAPSHOT.jar


=== Changing POM

By default, Maven uses Java 5, but it is possible to add the Compiler Plugin to tell Maven which JDK version to use for compiling your project.

Insert the following XML snippet just before the *<dependencies>* tag:

[source, XML]
[subs="verbatim,attributes"]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.1</version>
    <configuration>
        <source>1.7</source>
        <target>1.7</target>
    </configuration>
</plugin>
----

This additionally allows you to choose the source and target JDK versions (in this case, it means that the compiler accepts Java Version 1.7 statements).

It could be a good idea to set JUnit to a more recent version, which at this time is 4.11. Just edit the version number within the <dependency> element:

[source, XML]
[subs="verbatim,attributes"]
----
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.11</version>
    <scope>test</scope>
</dependency>
----

We don't need to think about the transitive dependencies, as Maven will handle them for us;
we just need to change the <version> value and re-run the build.

=== Analyzing the console and fixing warnings

The Maven console output is the most authoritative source (along with the effective POM that will be discussed later) to
know what a Maven build is doing; it is a very good exercise to read the console output and see what operations are performed by the Maven build.

You should also see one (type of) warning:

  [WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!

This warning is triggered by the resources:resources goal execution and it's informing us
that—since we haven't specified an encoding in the build—the plugin will use one of the current platforms, which is a common build portability issue.

To fix the issue, we just need to define a property:

[source, XML]
[subs="verbatim,attributes"]
----
<properties>
  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
</properties>
----

Well done! Your final pom.xml file should look like this:

[source, XML]
[subs="verbatim,attributes"]
----
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mycompany.demo</groupId>
    <artifactId>myapp</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>

    <name>myapp JAR application</name>
    <url>http://maven.apache.org</url>

    <properties>
       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>1.7</source>
                    <target>1.7</target>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>2.4</version>
                <configuration>
                    <archive>
                     <manifest>
                    <mainClass>com.mycompany.demo.App</mainClass>
                     </manifest>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
----